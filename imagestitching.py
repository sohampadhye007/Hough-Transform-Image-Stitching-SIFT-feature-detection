# -*- coding: utf-8 -*-
"""imageStitching.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FNqUircZA68RttW2s9z-jptUqGy1leFT

#(M22RM007-Soham Padhye)
#Initial Code that only uses the inbuilt stitch function to stitch the images
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import imutils

# Load the images
img1 = cv2.imread('1a.jpeg')
img2 = cv2.imread('1b.jpeg')
img3 = cv2.imread('1c.jpeg')

# Create a stitcher object that is already available in opencv
stitcher = cv2.createStitcher() if imutils.is_cv3() else cv2.Stitcher_create()

# Stitch the images status shows whether stitching is successfull or not and also shows other status related to stitching
(status, stitched) = stitcher.stitch([img1,img2,img3])

# Display the output
cv2_imshow( stitched)

"""


# Checking the size of images and resizing"""

import cv2
import numpy as np

# Load the images
img1 = cv2.imread('1a.jpeg')
img2 = cv2.imread('1b.jpeg')
img3 = cv2.imread('1c.jpeg')
img1=cv2.resize(img1,(358,273)) 


# Rotate the first image by 5 degrees
(h, w) = img3.shape[:2]
center = (w // 2, h // 2)
M = cv2.getRotationMatrix2D(center, 4, 1.09)
img3_rotated = cv2.warpAffine(img3, M, (w, h))

img3_rotated=cv2.resize(img3_rotated,(358,273))
# Get shape of image
height, width, channels = img3_rotated.shape

# Print shape of image
print("Height:", height)
print("Width:", width)
print("Channels:", channels)

# Get shape of image
height, width, channels = img2.shape

# Print shape of image
print("Height:", height)
print("Width:", width)
print("Channels:", channels)

# Get shape of image
height, width, channels = img2.shape

# Print shape of image
print("Height:", height)
print("Width:", width)
print("Channels:", channels)


# Display the output
cv2_imshow(img3_rotated)
cv2_imshow(img1)
cv2_imshow(img2)


img3=img3_rotated

"""# Trying to stitch first image and second image uisng inbuilt stitch function 
#Then stitch the previously stitched image(Img1+Img2) with Img3 and see the result
"""

# Load the images
img1 = img1
img2=img2

# Initialize stitcher
stitcher = cv2.Stitcher_create()

# Stitch images together
(status, stitched) = stitcher.stitch((img1, img2))
print(status)

# Display panorama
cv2_imshow(stitched)

# Initialize stitcher
stitcher = cv2.Stitcher_create()

# Stitch images together
(status, stitched) = stitcher.stitch((stitched, img3))
print(status)

# Display panorama
cv2_imshow(stitched)

"""# Creating the stitcher classs to Stitch the images"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

class ImageStitcher:
    def __init__(self, left_image_path, right_image_path):
        self.left_image = left_image_path
        self.right_image = right_image_path

    def stitch_images(self):
        sift = cv2.xfeatures2d.SIFT_create()
        key_points1, descriptor1 = sift.detectAndCompute(self.right_image, None)
        key_points2, descriptor2 = sift.detectAndCompute(self.left_image, None)

        bf = cv2.BFMatcher()
        matches = bf.knnMatch(descriptor1, descriptor2, k=2)
        best_matches = []

        for i, j in matches:
            if i.distance < 0.3 * j.distance:
                best_matches.append(i)

        kp1_indices = np.float32([key_points1[x.queryIdx].pt for x in best_matches])
        kp2_indices = np.float32([key_points2[x.trainIdx].pt for x in best_matches])

        kp1_indices = kp1_indices.reshape(-1, 1, 2)
        kp2_indices = kp2_indices.reshape(-1, 1, 2)

        HG, _ = cv2.findHomography(kp1_indices, kp2_indices, cv2.RANSAC, 5.0)

        result = cv2.warpPerspective(self.right_image, HG, (self.right_image.shape[1] + self.left_image.shape[1], self.left_image.shape[0]))
        result[0:self.left_image.shape[0], 0:self.left_image.shape[1]] = self.left_image

        return result

"""# Creating the instance for stitcher class"""

stitcher = ImageStitcher(img1,img2)
result_left = stitcher.stitch_images()
cv2_imshow(result_left)

"""# Creating the function to crop the image (To remove the black part from image)"""

def cropImage(img):

    # Convert the image to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Get the width and height of the image
    h, w = gray.shape[:2]

    # Find the index of the leftmost column with nonzero pixels so that we can crop
    threshold=70
    leftmost_col = 0
    while leftmost_col < w and cv2.countNonZero(gray[:, leftmost_col]) <= threshold:
        leftmost_col += 1

    # Find the index of the rightmost column with nonzero pixels so that we can crop it
    rightmost_col = w - 1
    while rightmost_col >= 0 and cv2.countNonZero(gray[:, rightmost_col]) <= threshold:
        rightmost_col -= 1

    # Crop the image to remove the black strips on the left and right
    cropped = img[:, leftmost_col:rightmost_col+1]


    # Display the original and cropped images side by side
    cv2_imshow(cropped)
    return cropped

cropped_left=cropImage(result_left)

"""# Pre-Processing the third image"""

# Rotate the first image by 4 degrees
img3=cv2.imread('1c.jpeg')
(h, w) = img3.shape[:2]
center = (w // 2, h // 2)
M = cv2.getRotationMatrix2D(center, 4, 1)
img3 = cv2.warpAffine(img3, M, (w, h))
cv2_imshow(img3)

cropped_third=cropImage(img3)

stitcher = ImageStitcher(img2, img3)
result_right = stitcher.stitch_images()
cv2_imshow(result_right)

cropped_right=cropImage(result_right)

stitcher = ImageStitcher(cropped_left,cropped_right)
panorama_raw = stitcher.stitch_images()
cv2_imshow(panorama_raw)

"""# Final Result"""

panorama=cropImage(panorama_raw)

"""# Custom images panorama stitching"""

img1 = cv2.imread('1.jpg')
img2 = cv2.imread('2.jpg')
img3 = cv2.imread('3.jpg')

stitcher = ImageStitcher(img1,img2)
panorama_raw = stitcher.stitch_images()
cv2_imshow(panorama_raw)

panorama1=cropImage(panorama_raw)

stitcher = ImageStitcher(img2,img3)
panorama_raw = stitcher.stitch_images()
cv2_imshow(panorama_raw)

panorama2=cropImage(panorama_raw)

stitcher = ImageStitcher(panorama1,panorama2)
panorama_raw = stitcher.stitch_images()
cv2_imshow(panorama_raw)

panorama=cropImage(panorama_raw)

