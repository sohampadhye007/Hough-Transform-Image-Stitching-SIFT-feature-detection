# -*- coding: utf-8 -*-
"""HoughTrans.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QzI47xlZ8EJJkAXG23kMXI35hahZ9rMW
"""

from matplotlib import pyplot as plt
import numpy as np
import math
import cv2
import time

"""# Creating the HoughLines class"""

#Defining the class to detect the hough Lines
class HoughTransform:
    def __init__(self, image_path):
        #Giving the image path
        self.image_path = image_path

    def hough_line(self, edge_image):
         
        # Theta 0 - 180 degree
        theta = np.arange(0, 180, 1)
        #Calculate the cos theta and sine theta values in advance to reduce the calculation time
        cos_values = np.cos(np.deg2rad(theta))
        sin_values = np.sin(np.deg2rad(theta))

        # Generate an accumulator matrix to store the values which is required in Hough Transform for Voting

        #rho_range is a variable used to set the number of rows in the Hough accumulator array. 
        #it is computed by height and width of the image.
        rho_range = round(math.sqrt(edge_image.shape[0]**2 + edge_image.shape[1]**2))
        accumulator = np.zeros((2 * rho_range, len(theta)), dtype=np.uint8)

        # Threshold to get edges pixel location (x,y)
        #If the pixel value in black and white image is 255 then it might be edge pixel
        edge_pixels = np.where(edge_image == 255)

        #Using Zip inbuilt python function get tuples where the i-th tuple contains the i-th element from each of the iterables.
        coordinates = list(zip(edge_pixels[0], edge_pixels[1]))

        # Calculate rho value for each edge location (x,y) with all the theta range
        for p in range(len(coordinates)):
            for t in range(len(theta)):
                rho = int(round(coordinates[p][1] * cos_values[t] + coordinates[p][0] * sin_values[t]))
                accumulator[rho, t] += 2  # Suppose add 1 only, Just want to get a clear result
        
        #Return the accumulator that is useful in next function
        print(accumulator)
        return accumulator

    def detect_lines(self):
        # read image then convert to grayscale and find the edges by Canny Edge Detection
        image = cv2.imread(self.image_path)
        grayscale = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        edge_image = cv2.Canny(grayscale, 50, 150)

        # Apply Hough Line Transform by passing loaded image
        accumulator = self.hough_line(edge_image)

        #Set the Threshold values then draw the line if line is not visible then decrease the threshold
        #This threshold is nothing but Voting
        #Collesct all edge pixels
        edge_pixels = np.where(accumulator > 90)
        coordinates = list(zip(edge_pixels[0], edge_pixels[1]))

        # Use line equation to draw detected line on an original image
        #Use the polar line equation in polar coordinate system to draw the lines
        #rho = xcos(theta) + ysin(theta), where x and y are the coordinates of the edge point and theta is the corresponding angle.

        for i in range(len(coordinates)):
            cos_value = np.cos(np.deg2rad(coordinates[i][1]))
            sin_value = np.sin(np.deg2rad(coordinates[i][1]))
            x0 = cos_value * coordinates[i][0]
            y0 = sin_value * coordinates[i][0]
            x1 = int(x0 + 1000 * (-sin_value))
            y1 = int(y0 + 1000 * (cos_value))
            x2 = int(x0 - 1000 * (-sin_value))
            y2 = int(y0 - 1000 * (cos_value))

            #Draw the line using inbuilt function
            cv2.line(image, (x1, y1), (x2, y2), (255, 127, 0), 1)

        # showing the images of accumulator and hough lines
        plt.subplot(121), plt.imshow(image)
        plt.subplot(122), plt.imshow(accumulator)
        plt.show()

if __name__ == '__main__':
    start_time=time.time() #Starting the time for calculating the time requirement of program
    hough = HoughTransform('lg.jpg')
    hough.detect_lines()
    end_time=time.time()#End the time

"""# Check the time required to execute the custom Hough Lines class"""

total_time1=end_time-start_time
print(f"Time requird to run the program is {total_time1} seconds")

"""# Use Inbuilt function HoughLines method to find the lines"""

# Now doing the same thing that is line detection by using the inbuilt OpenCv function
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('lg.jpg')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply Canny edge detection for finding the edges
edges = cv2.Canny(gray, 50, 150, apertureSize=3)
cv2_imshow(edges)

# Apply Hough transform
start_time = time.time()  # Start the timer

#To get the good amount of lines set the threshold value in HoughLines
lines = cv2.HoughLines(edges, 1, np.pi/180, 50)

print(f"coordinates of detecteed lines are {lines}\n")

# Draw the detected lines on the original image
if lines is not None:
    for line in lines:
        rho, theta = line[0]
        a = np.cos(theta)
        b = np.sin(theta)
        x0 = a*rho
        y0 = b*rho
        x1 = int(x0 + 1000*(-b))
        y1 = int(y0 + 1000*(a))
        x2 = int(x0 - 1000*(-b))
        y2 = int(y0 - 1000*(a))
        cv2.line(img, (x1, y1), (x2, y2), (0, 0, 255), 2)

end_time = time.time()  # Stop the timer


# Show the final image
cv2_imshow(img)

"""#Check the time required to execute the inbuilt Hough Lines method in OpenCv"""

total_time2 = end_time - start_time
print(f"Time required to run the program: {total_time2} seconds")

"""# Calculating the time difference in executing the inbuilt function and custom class"""

#Time diffrence between my implementation and OpenCV library function 

print(f"Time diffrence between my implementation and OpenCV library function is {abs(total_time1-total_time2)}")